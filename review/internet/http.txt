一、HTTP介绍

  HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议
  HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议
  在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS
  HTTP默认的端口号为80，HTTPS的端口号为443



二、工作流程

一次HTTP操作称为一个事务，其工作过程可分为四步：
1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。
2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。
3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。
如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了

当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？

实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页

我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的 

代理服务器就是网络信息的中转站，有什么功能呢？

1. 提高访问速度， 大多数的代理服务器都有缓存功能。

2. 突破限制， 也就是FQ了（翻墙）

3. 隐藏身份

  HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。
  在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。



三、头域

每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。

3.1、请求信息：
  发出的请求信息格式如下：
●请求行，例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件。
●（请求）头，例如Accept-Language: en
●空行
●可选的消息体　请求行和标题必须以<CR><LF>作为结尾（也就是，回车然后换行）。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1协议中，所有的请求头，除post外，都是可选的

三个部分分别是：请求行、请求头、请求正文。


3.2、响应消息
  客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误编码、服务器信息、实体元信息以及必要的实体内容。根据响应类别的类别，服务器响应里可以含实体内容，但不是所有的响应都有实体内容。
响应头第一行也称为状态行

三个部分分别是：状态行、消息报头、响应正文。


3.3、请求方法
  HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：
  OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
  HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
  GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
  POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
  PUT - 向指定资源位置上传其最新内容。
  DELETE - 请求服务器删除Request-URI所标识的资源。
  TRACE- 回显服务器收到的请求，主要用于测试或诊断。
  CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
  PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。

GET:取出资源
POST:在服务器新建资源
PUT:在服务器更新资源（全体资源）
PATCH: 部分更新（部分资源）
DELETE:删除资源
HEAD：获取报文头部
OPTIONS: 询问支持的方法
TRACE:追踪路径
CONNECT: 要求用隧道协议链接代理

 
3.4、HTTP常见的请求头

If-Modified-Since
If-None-Match
Pragma
Cache-Control：指定请求和响应遵循的缓存机制
Accept：浏览器端可以接受的MIME类型
Accept-Encoding：浏览器申明自己可接收的编码方法
Accept-Language：浏览器申明自己接收的语言
Accept-Charset：浏览器可接受的字符集
User-Agent：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本
Cookie：最重要的请求头之一, 将cookie的值发送给HTTP服务器

3.5、HTTP常见的响应头

Set-Cookie：非常重要的header, 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie
Allow：服务器支持哪些请求方法（如GET、POST等）


四、解决HTTP无状态的问题

4.1、通过Cookies保存状态信息
通过Cookies，服务器就可以清楚的知道请求2和请求1来自同一个客户端

4.2、通过Session保存状态信息

 Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息

 Session的实现方式：
  1、使用Cookie来实现
  2、使用URL回写来实现

4.3、通过表单变量保持状态
4.4、通过QueryString保持状态

五、cookie和session

http是一种无状态请求机制，并不能保存信息，因此，引入了cookie

cookie: 是浏览器本地存储的一种机制，与服务器无关，保存服务器发送给用户的id等，包括浏览记录，账号密码等，保存的类型为键值对

访问机制：第一次访问，服务器给浏览器分配ID，第二次访问 带着ID访问服务器，服务器根据ID就能知道用户的一些信息。

但是cookie这种机制，一旦当别人得到了你的电脑，就能得到你cookie里所有的信息，并不安全，因此，引出了 session机制


session 根据用户名和密码加密生成数据ID，是服务器生成的，数据都比较具有较高的安全性。 

访问服务器的时候，加上session，只需要将session的ID带过去，服务器就知道了用户，不在需要用户名和密码，

Cookie和Session有以下明显的不同点：
1）Cookie将状态保存在客户端，Session将状态保存在服务器端；
2）Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；
3）Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；
4）就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些。因为它不会任意读取客户存储的信息


六、URL详解

URL(Uniform Resource Locator) 地址用于描述一个网络上的资源， 基本格式如下
schema://host[:port#]/path/.../[;url-params][?query-string][#anchor]
　　scheme 指定低层使用的协议(例如：http, https, ftp)
　　host HTTP服务器的IP地址或者域名
　　port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/
　　path 访问资源的路径
　　url-params
　　query-string 发送给http服务器的数据
　　anchor- 锚

URL 的一个例子：
http://www.mywebsite.com/sj/test;id=8079?name=sviergn&x=true#stuff
Schema: http
host: www.mywebsite.com
path: /sj/test
URL params: id=8079
Query String: name=sviergn&x=true
Anchor: stuff

七、Get和Post方法的区别

Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.

我们看看GET和POST的区别

1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码


 

八、HTTP协议是无状态的和Connection: keep-alive的区别

  无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系

  HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）

  从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间


九、http的状态响应码

1**(信息类)：表示接收到请求并且继续处理
100――客户必须继续发出请求
101――客户要求服务器根据请求转换HTTP协议版本

2**(响应成功)：表示动作被成功接收、理解和接受
200――表明该请求被成功地完成，所请求的资源发送回客户端
201――提示知道新文件的URL
202――接受和处理、但处理未完成
203――返回信息不确定或不完整
204――请求收到，但返回信息为空
205――服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206――服务器已经完成了部分用户的GET请求

3**(重定向类)：为了完成指定的动作，必须接受进一步处理
300――请求的资源可在多处得到
301――本网页被永久性转移到另一个URL
302――请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
303――建议客户访问其他URL或访问方式
304――自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
305――请求的资源必须从服务器指定的地址得到
306――前一版本HTTP中使用的代码，现行版本中不再使用
307――申明请求的资源临时性删除
4**(客户端错误类)：请求包含错误语法或不能正确执行
400――客户端请求有语法错误，不能被服务器所理解
401――请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
HTTP 401.1 - 未授权：登录失败
　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
　　HTTP 401.3 - ACL 禁止访问资源
　　HTTP 401.4 - 未授权：授权被筛选器拒绝
HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
402――保留有效ChargeTo头响应
403――禁止访问，服务器收到请求，但是拒绝提供服务
404――一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
405――用户在Request-Line字段定义的方法不允许
406――根据用户发送的Accept拖，请求资源不可访问
407――类似401，用户必须首先在代理服务器上得到授权
408――客户端没有在用户指定的饿时间内完成请求
409――对当前资源状态，请求不能完成
410――服务器上不再有此资源且无进一步的参考地址
411――服务器拒绝用户定义的Content-Length属性请求
412――一个或多个请求头字段在当前请求中错误
413――请求的资源大于服务器允许的大小
414――请求的资源URL长于服务器允许的长度
415――请求资源不支持请求项目格式
416――请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
417――服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。
5**(服务端错误类)：服务器不能正确执行一个正确的请求
HTTP 500 - 服务器遇到错误，无法完成请求
　　HTTP 500.100 - 内部服务器错误 - ASP 错误
　　HTTP 500-11 服务器关闭
　　HTTP 500-12 应用程序重新启动
　　HTTP 500-13 - 服务器太忙
　　HTTP 500-14 - 应用程序无效
　　HTTP 500-15 - 不允许请求 global.asa
　　Error 501 - 未实现
HTTP 502 - 网关错误
HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常